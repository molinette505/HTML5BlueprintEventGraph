/**
 * Node Class
 * Represents a single logical node in the graph.
 * It holds the state (position, expanded/collapsed), configuration (name, color),
 * and lists of Input/Output Pins.
 * This is the "Model". The "View" is generated by NodeRenderer.js.
 */
class Node {
    /**
     * @param {Number} id - Unique ID generated by the Graph.
     * @param {Object} template - The JSON definition for this node type (from Nodes.js).
     * @param {Number} x - X position on the canvas.
     * @param {Number} y - Y position on the canvas.
     */
    constructor(id, template, x, y) {
        this.id = id;
        this.x = x;
        this.y = y;
        
        // Node Configuration
        this.name = template.name;
        this.color = template.color || "var(--header-bg)";
        this.width = template.width; // Optional override for node width
        
        // Layout Flags
        this.hideHeader = template.hideHeader || false; // Used for "Compact" nodes (like Math)
        this.centerLabel = template.centerLabel || null; // Used for Math symbols (+, -, etc)
        
        // State: Tracks if "Advanced" pins are currently visible
        this.showAdvanced = false;

        // Function binding
        this.functionId = template.functionId || null;
        // Look up the real function or null if none exists
        this.jsFunctionRef = window.FunctionRegistry ? window.FunctionRegistry[this.functionId] : null;
        
        // Cache for the result of the calculation (for Pure nodes)
        this.executionResult = null;

        // Instantiate Pin Models
        this.inputs = (template.inputs || []).map((p, i) => new Pin(this, i, 'input', p));
        this.outputs = (template.outputs || []).map((p, i) => new Pin(this, i, 'output', p));
    }

    /**
     * Helper to retrieve data from a specific input pin.
     * Currently returns the value from the Widget (text box, checkbox, etc).
     * @param {Number} index - The index of the input pin.
     * @returns {any} The value, or null if invalid.
     */
    getInputValue(index) {
        if (!this.inputs[index]) return null;
        
        // Return local widget value if it exists.
        // Note: A full simulation engine would check for an incoming Connection here first.
        if (this.inputs[index].widget) {
            return this.inputs[index].widget.value;
        }
        return null; 
    }
    
    /**
     * Checks if this node contains any pins marked as 'advanced'.
     * Used by NodeRenderer to decide if the Expansion Arrow should be drawn.
     * @returns {Boolean}
     */
    hasAdvancedPins() {
        return this.inputs.some(p => p.advanced) || this.outputs.some(p => p.advanced);
    }

    /**
     * Serializes the node state for Copy/Paste or Saving.
     * Captures position, template identifier, and current input widget values.
     * @returns {Object} JSON-safe object.
     */
    toJSON() {
        return {
            id: this.id, // Needed for connection mapping during full save
            name: this.name, // Template Name identifier
            x: this.x,
            y: this.y,
            // We only need to save Input values (widgets). Outputs are computed.
            inputs: this.inputs.map(p => ({
                name: p.name,
                value: p.value // The current value from the widget
            }))
        };
    }
}